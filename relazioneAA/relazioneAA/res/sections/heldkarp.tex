\section{Risultati degli algoritmi}
Questa sezione risponderà alla Domanda 1: verranno riportati sotto forma di tabella i risultati dei costi per il problema TSP dei grafi richiesti, il tempo di esecuzione di ogni algoritmo e l'errore relativo rispetto alla soluzione esatta. I risultati ottenuti,poi, verranno opportunamente discussi.

\subsection{Domanda 1}
Eseguite i tre algoritmi che avete implementato (Held-Karp, euristica costruttiva e 2-approssimato) sui 13 grafi del dataset. Mostrate i risultati che avete ottenuto in una tabella come quella sottostante. Le righe della corrispondono alle istanze del problema. Le colonne mostrano, per ogni algoritmo, il peso della soluzione trovata, il tempo di esecuzione e l'errore relativo calcolato come $(SoluzioneTrovata - SoluzioneOttima)/SoluzioneOttima$. Potete aggiungere altre informazioni alla tabella che ritenete interessanti. 
\image{1}{estab}{Esempio di tabella riportante i risultati ottenuti}
\subsubsection{Svolgimento}
\label{tab}
\begin{center}
	\scriptsize
	\begin{longtable}{|c|c|c|c|c|c|c|c|c|c|}	
	\hline
		\multirow{2}{*}{\textbf{Istanza}} & \multicolumn{3}{c|}{\textbf{Held-Karp}} & \multicolumn{3}{c|}{\textbf{Cheapest Insertion}} & \multicolumn{3}{c|}{\textbf{TriangleTSP}} \\ \cline{2-10}
		 &\textbf{Soluzione}& \textbf{Tempo (s)} & \textbf{Errore (\%)} & \textbf{Soluzione}& \textbf{Tempo (s)} & \textbf{Errore (\%)} & \textbf{Soluzione}& \textbf{Tempo (s)} & \textbf{Errore (\%)} \\ \hline
		\endfirsthead
		\multicolumn{10}{|c|}%
		{\tablename\ \thetable\ \ --\  \textit{continuazione della pagina precedente}} \\
		\hline
		\multirow{2}{*}{\textbf{Istanza}} & \multicolumn{3}{c|}{\textbf{Held-Karp}} & \multicolumn{3}{c|}{\textbf{Held-Karp}} & \multicolumn{3}{c|}{\textbf{Held-Karp}} \\ \cline{2-10}
		 &\textbf{Soluzione}& \textbf{Tempo (s)} & \textbf{Errore (\%)} & \textbf{Soluzione}& \textbf{Tempo (s)} & \textbf{Errore (\%)} & \textbf{Soluzione}& \textbf{Tempo (s)} & \textbf{Errore (\%)} \\ \hline
		\endhead
		\hline \multicolumn{10}{|r|}{\textit{Continua nella pagina seguente}} \\
		\endfoot
		\endlastfoot
		berlin52.tsp & 17441 & 120,0174 & 131,25 & 9004 & 0,0096 & 19,38& 10402 &0,0074 &37.92 \\ \hline
		burma14.tsp & 3323 & 0,2029 & 0,0 & 3588 & 0,0003 & 7,97 &4003 & 0,0002&20.46\\ \hline
		ch150.tsp & 47935 & 120,95 & 634,30 & 7998 & 0,0678 & 22,52 &9126 &0,02343 &39.80  \\ \hline
		d493.tsp & 111947 & 120,4769&219,83 & 39969 & 0,4976 & 14,19 &45300 &0,1063 &29.42 \\ \hline
		dsj1000.tsp & \scriptsize 551274242 &120,0012 &2854,36 & 22291165 & 7,5382 & 19,46 &25526005 &0,5358 &36.80 \\ \hline
		eil51.tsp&986 &120,0005 &131,46 & 494 &0,0006 & 15,96 &614 & 0,0009 &44.13 \\ \hline
		gr202.tsp&55127 &119,9998 &37,26 & 46480 & 0,0406 & 15,74 &52615 & 0,0189& 31.01\\ \hline
		gr229.tsp&176212 & 120,0008&30,91 & 153896 & 0,0493 & 14,33 &179335 &0,0249 &33.23 \\ \hline
		kroA100.tsp& 164223 & 120,0003 & 671,65 & 24942 & 0,0038 & 17,20&30536 &0,0014 &43.48 \\ \hline
		kroD100.tsp& 144125 &120,0012 &576,83 &25204 & 0,0036 & 18,36 &28599 &0,0017 &34.31 \\ \hline
		pcb442.tsp& 202233&120,4061 &298,27 & 60834 & 0,3954 & 19,80 &68841 &0,0901 & 35.57\\ \hline
		ulysses16.tsp&6859 &0,5584 & 0,0 & 7368 & 0,0001 & 7,42&7788 & 0,0001 & 13.54\\ \hline
		ulysses22.tsp&7013 &59,4115 &0,0 &  7709 & 0,0001 & 9,92 &8308 &0,0001 &18.47 \\ \hline		 
     \caption{Risultati dei tre algoritmi implementati rispetto alla domanda 1}
     \label{results}
	\end{longtable}
\end{center}\vspace{-40pt}

\subsection{Domanda 2}
Commentate i risultati che avete ottenuto: come si comportano gli algoritmi rispetto alle varie istanze? C'è un algoritmo che riesce sempre a fare meglio degli altri rispetto all'errore di approssimazione? Quale dei tre algoritmi che avete implementato è più efficiente? 

\subsubsection{Svolgimento}
\begin{itemize}
	\item \textbf{Come si comportano gli algoritmi rispetto alle varie istanze?}
	\begin{itemize}
		\item \texttt{HeldKarp}: nelle istanze fino di 14 e 16 nodi l'algoritmo termina quasi immediatamente, restituendo la soluzione ottima. Nell'istanza con 22 nodi impiega poco meno di un minuto per trovarla. Per tutte le altre istanze, occorre dare un tempo limite a disposizione dell'algoritmo in quanto impiegherebbe decisamente troppo tempo per calcolare la soluzione ottima. Pur interrompendo la computazione, non è possibile fare alcuna previsione sulla qualità della soluzione ritornata calcolata fino a quel punto, che arriva anche ad essere del 2854,36\% nel caso di \texttt{disj1000.tsp}.
		\item \texttt{CheapestInsertion}: l'algoritmo ritorna una soluzione 2-approssimata\footnote{grazie al vincolo rispettato di disuguaglianza triangolare} quasi immediatamente, fatta eccezione per \texttt{disj1000.tsp} che impiega circa 7,5 secondi. Ogni soluzione ritornata ha un errore che appartiene all'intervallo $[7.97 - 22.52]$\%: in media ogni soluzione ha un errore relativo del 15,56\% rispetto alla sua soluzione ottima. Un notevole risultato, tenendo conto che potrebbe teoricamente ritornare una soluzione con errore relativo al più del 200\%.
		\item \texttt{TriangleTSP}: l'algoritmo ritorna una soluzione 2-approssimata quasi immediatamente per tutte le istanze del dataset. Ogni soluzione ritornata possiede un errore relativo che appartiene all'intervallo $[13.54 - 44.13]$\%: in media ogni soluzione ha un errore relativo del 30.74\%. Un risultato quasi doppio rispetto all'euristica \texttt{CheapestInsertion}: ulteriori chiarimenti saranno forniti nella sezione \S\ref{ci-ttsp}
	\end{itemize}
	\item \textbf{C'è un algoritmo che riesce sempre a fare meglio degli altri rispetto all'errore di approssimazione?}
	\begin{itemize}
		\item \texttt{HeldKarp} riesce sempre a fare meglio di \texttt{CheapestInsertion} e \texttt{TriangleTSP} nelle istanze con meno di 23 nodi, vale a dire \texttt{burma14.tsp, ulysses16.tsp} e \texttt{ulysses22.tsp} perché riesce a trovare la soluzione ottima. Per tutte le altre istanze del dataset, \texttt{CheapestInsertion} riesce sempre a trovare una soluzione più vicina alla soluzione ottima rispetto agli altri due algoritmi implementati.
	\end{itemize}
	\item \textbf{Quale dei tre algoritmi che avete implementato è più efficiente?}
	\begin{itemize}
		\item Considerando il termine \quotes{efficienza} ed il suo significato in campo informatico, inteso come la capacità di utilizzare meno risorse\footnote{tempo di utilizzo della CPU e memoria} possibile durante la sua esecuzione, l'algoritmo più efficiente si rivela essere \texttt{TriangleTSP} perché è corretto rispetto al vincolo di 2-approssimazione ed impiega meno risorse di \texttt{CheapestInsertion}. Quest'ultimo, tuttavia, riesce a trovare una soluzione quasi il doppio più accurata del primo, come è possibile vedere a Figura~\ref{confronto}, a fronte dell'utilizzo di risorse più che accettabili per le istanze di TSP fornite. \`{E} per questo che ci sentiamo di dire che l'algoritmo il quale, mediamente, riesce a combinare \textbf{efficienza} ed \textbf{efficacia} meglio di tutti sia proprio \texttt{CheapestInsertion} per le istanza di grafi non troppo grandi. Infatti il tempo di esecuzione per \texttt{CheapestInsertion} aumenta esponenzialmente con l'aumentare della taglia del grafo, non giustificando più la differenza di accuratezza tra \texttt{CheapestInsertion} e \texttt{TringleTSP}.
	\end{itemize}
\end{itemize}


\paragraph{Discussione su \texttt{CheapestInsertion} e \texttt{TriangleTSP}} \label{ci-ttsp}
Entrambi gli algoritmi sono una 2-approssimazione per TSP, ma riportano risultati differenti: \texttt{CheapestInsertion} richiede più tempo per essere eseguito rispetto a \texttt{TriangleTSP}, ma ottiene un errore relativo minore.\eqcapo 
Per capire dunque quale dei due algoritmi sia più efficiente ed efficace, è possibile osservare gli istogrammi in Figura~\ref{confronto} che mostrano prima la differenza del tempo di esecuzione dei due algoritmi su scala logaritmica per i vari grafi, poi il tempo di esecuzione su una scala normale ed infine il rispettivo errore relativo. Confrontando il primo e terzo istogramma è possibile vedere come per una differenza di tempo di computazione relativamente basso si ottiene un notevole miglioramento per l'errore relativo, infatti \texttt{TriangleTSP} raggiunge in media un errore relativo più alto ($\sim$30\%) rispetto a \texttt{CheapestInsertion} ($\sim$16\%). Se si osserva il secondo istogramma si può vedere come con grafi di taglia maggiore il tempo di esecuzione per \texttt{CheapestInsertion} aumenti esponenzialmente rispetto a \texttt{TriangleTSP}, basti osservare il tempo di esecuzione per i grafi \texttt{d449.tsp} e \texttt{dsj1000.tsp}: dunque per grafi di grande taglia è consigliabile utilizzare \texttt{TriangleTSP}, altrimenti \texttt{CheapestInsertion}.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{confronto}
	\caption{Confronto tra \texttt{CheapestInsertion} e \texttt{TriangleTSP}}
	\label{confronto}
\end{figure}

\newpage
\section{Descrizione degli algoritmi}
\subsection{HeldKarp}
Le strutture dati utilizzate dall'algoritmo \texttt{HeldKarp} sono essenzialmente 3:
\begin{itemize}
	\item \texttt{AdjacentMatrix}, cioè la matrice di adiacenza dei nodi dell'istanza di TSP, trattata come matrice $n\times n$ simmetrica alla diagonale ma implementata come matrice diagonale superiore come specificato in \S\ref{adjmat};
	\item \texttt{Pair<Integer, ArrayList<Integer>} letteralmente la chiave $<\!\!d,S\!\!>$ che consiste nella coppia di valori di tipo \texttt{Integer} e \texttt{ArrayList<Integer>}, che rappresentano rispettivamente il nodo-destinazione e l'insieme di nodi da visitare, partendo dal nodo 0 e finendo al nodo-destinazione appena illustrato;
	\item \texttt{HashMap<Pair<Integer, ArrayList<Integer>>, Integer>}, che mappa a coppia $<\!\!d,S\!\!>$ di cui sopra ad un valore di tipo \texttt{Integer}. Questa struttura dati serve a rappresentare due entità fondamentali per l'algoritmo \texttt{HeldKarp}:
	\begin{itemize}
		\item \texttt{d}, rappresentata da $d[v,S]$ nello pseudocodice e descritta in \ref{adjmat};
		\item \texttt{pi}, rappresentata da $\pi[v,S]$ nello pseudocodice e descritta in \ref{adjmat}.
	\end{itemize}
\end{itemize}

L'algoritmo parte formando l'insieme dei nodi di partenza $V$, cioè tutti i nodi dell'istanza di TSP e invocando \texttt{HeldKarpCore}.\eqcapo

L'algoritmo \texttt{HeldKarpCore} è il vero e proprio algoritmo di Held e Karp. Dopo aver gestito i casi base in tempo \comp{1}, costruisce l'insieme $S\setmin \{v\}$ indicato nel codice con il nome di \texttt{S\_new} in tempo \comp{n-1} = \comp{n}.\eqcapo

A questo punto esaminiamo il ciclo \texttt{for}. Esso, tolte le chiamate ricorsive, itera su tutti i vertici in $S\setmin \{v\}$ e quindi impiega un tempo \comp{n}. Analizzando ora le chiamate ricorsive, si osserva che terminano immediatamente quando la coppia $<\!\!v, S\!\!>\ \in d$, ovvero quando\\ \texttt{d.containsKey(Pair<v,S>) = true}: questo ci fa dedurre che le chiamate ricorsive che eseguono \texttt{HeldKarpCore} casi base esclusi, è limitato superiormente dal numero di elementi indicizzati in \texttt{d}. Questo numero risulta essere $\leq |V|\cdot 2^{|V|}$, con $|V|$: numero di nodi dell'istanza di TSP.\eqcapo
Indicando con $n$ la quantità $|V|$ e tenendo conto anche del tempo necessario alla costruzione dell'insieme $S\setmin \{v\}$, possiamo quindi affermare che il tempo totale impiegato da \texttt{HeldKarpCore} è pari a 
\comp{n+n}$\cdot$\comp{n\cdot 2^n} = \comp{(2n)\cdot n \cdot 2^n} = \comp{n^2\cdot 2^n}
\image{0.95}{heldkarp}{Snippet degli algoritmi \texttt{HeldKarp} ed \texttt{HeldKarpCore}}

\input{./res/sections/Heuristic}
\input{./res/sections/2approx}